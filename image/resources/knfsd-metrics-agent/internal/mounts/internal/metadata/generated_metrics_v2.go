// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for mounts metrics.
type MetricsSettings struct {
	NfsMountOpsPerSecond MetricSettings `mapstructure:"nfs.mount.ops_per_second"`
	NfsMountReadExe      MetricSettings `mapstructure:"nfs.mount.read_exe"`
	NfsMountReadRtt      MetricSettings `mapstructure:"nfs.mount.read_rtt"`
	NfsMountRPCBacklog   MetricSettings `mapstructure:"nfs.mount.rpc_backlog"`
	NfsMountWriteExe     MetricSettings `mapstructure:"nfs.mount.write_exe"`
	NfsMountWriteRtt     MetricSettings `mapstructure:"nfs.mount.write_rtt"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		NfsMountOpsPerSecond: MetricSettings{
			Enabled: true,
		},
		NfsMountReadExe: MetricSettings{
			Enabled: true,
		},
		NfsMountReadRtt: MetricSettings{
			Enabled: true,
		},
		NfsMountRPCBacklog: MetricSettings{
			Enabled: true,
		},
		NfsMountWriteExe: MetricSettings{
			Enabled: true,
		},
		NfsMountWriteRtt: MetricSettings{
			Enabled: true,
		},
	}
}

type metricNfsMountOpsPerSecond struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills nfs.mount.ops_per_second metric with initial data.
func (m *metricNfsMountOpsPerSecond) init() {
	m.data.SetName("nfs.mount.ops_per_second")
	m.data.SetDescription("nfsiostat Mount Operations Per Second")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricNfsMountOpsPerSecond) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNfsMountOpsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNfsMountOpsPerSecond) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNfsMountOpsPerSecond(settings MetricSettings) metricNfsMountOpsPerSecond {
	m := metricNfsMountOpsPerSecond{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricNfsMountReadExe struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills nfs.mount.read_exe metric with initial data.
func (m *metricNfsMountReadExe) init() {
	m.data.SetName("nfs.mount.read_exe")
	m.data.SetDescription("nfsiostat Mount Read EXE")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricNfsMountReadExe) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNfsMountReadExe) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNfsMountReadExe) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNfsMountReadExe(settings MetricSettings) metricNfsMountReadExe {
	m := metricNfsMountReadExe{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricNfsMountReadRtt struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills nfs.mount.read_rtt metric with initial data.
func (m *metricNfsMountReadRtt) init() {
	m.data.SetName("nfs.mount.read_rtt")
	m.data.SetDescription("nfsiostat Mount Read RTT")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricNfsMountReadRtt) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNfsMountReadRtt) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNfsMountReadRtt) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNfsMountReadRtt(settings MetricSettings) metricNfsMountReadRtt {
	m := metricNfsMountReadRtt{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricNfsMountRPCBacklog struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills nfs.mount.rpc_backlog metric with initial data.
func (m *metricNfsMountRPCBacklog) init() {
	m.data.SetName("nfs.mount.rpc_backlog")
	m.data.SetDescription("nfsiostat Mount RPC Backlog")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricNfsMountRPCBacklog) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNfsMountRPCBacklog) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNfsMountRPCBacklog) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNfsMountRPCBacklog(settings MetricSettings) metricNfsMountRPCBacklog {
	m := metricNfsMountRPCBacklog{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricNfsMountWriteExe struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills nfs.mount.write_exe metric with initial data.
func (m *metricNfsMountWriteExe) init() {
	m.data.SetName("nfs.mount.write_exe")
	m.data.SetDescription("nfsiostat Mount Write EXE")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricNfsMountWriteExe) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNfsMountWriteExe) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNfsMountWriteExe) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNfsMountWriteExe(settings MetricSettings) metricNfsMountWriteExe {
	m := metricNfsMountWriteExe{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricNfsMountWriteRtt struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills nfs.mount.write_rtt metric with initial data.
func (m *metricNfsMountWriteRtt) init() {
	m.data.SetName("nfs.mount.write_rtt")
	m.data.SetDescription("nfsiostat Mount Write RTT")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricNfsMountWriteRtt) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNfsMountWriteRtt) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNfsMountWriteRtt) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNfsMountWriteRtt(settings MetricSettings) metricNfsMountWriteRtt {
	m := metricNfsMountWriteRtt{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                  pdata.Timestamp
	metricNfsMountOpsPerSecond metricNfsMountOpsPerSecond
	metricNfsMountReadExe      metricNfsMountReadExe
	metricNfsMountReadRtt      metricNfsMountReadRtt
	metricNfsMountRPCBacklog   metricNfsMountRPCBacklog
	metricNfsMountWriteExe     metricNfsMountWriteExe
	metricNfsMountWriteRtt     metricNfsMountWriteRtt
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                  pdata.NewTimestampFromTime(time.Now()),
		metricNfsMountOpsPerSecond: newMetricNfsMountOpsPerSecond(settings.NfsMountOpsPerSecond),
		metricNfsMountReadExe:      newMetricNfsMountReadExe(settings.NfsMountReadExe),
		metricNfsMountReadRtt:      newMetricNfsMountReadRtt(settings.NfsMountReadRtt),
		metricNfsMountRPCBacklog:   newMetricNfsMountRPCBacklog(settings.NfsMountRPCBacklog),
		metricNfsMountWriteExe:     newMetricNfsMountWriteExe(settings.NfsMountWriteExe),
		metricNfsMountWriteRtt:     newMetricNfsMountWriteRtt(settings.NfsMountWriteRtt),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// Emit appends generated metrics to a pdata.MetricsSlice and updates the internal state to be ready for recording
// another set of data points. This function will be doing all transformations required to produce metric representation
// defined in metadata and user settings, e.g. delta/cumulative translation.
func (mb *MetricsBuilder) Emit(metrics pdata.MetricSlice) {
	mb.metricNfsMountOpsPerSecond.emit(metrics)
	mb.metricNfsMountReadExe.emit(metrics)
	mb.metricNfsMountReadRtt.emit(metrics)
	mb.metricNfsMountRPCBacklog.emit(metrics)
	mb.metricNfsMountWriteExe.emit(metrics)
	mb.metricNfsMountWriteRtt.emit(metrics)
}

// RecordNfsMountOpsPerSecondDataPoint adds a data point to nfs.mount.ops_per_second metric.
func (mb *MetricsBuilder) RecordNfsMountOpsPerSecondDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricNfsMountOpsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNfsMountReadExeDataPoint adds a data point to nfs.mount.read_exe metric.
func (mb *MetricsBuilder) RecordNfsMountReadExeDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricNfsMountReadExe.recordDataPoint(mb.startTime, ts, val)
}

// RecordNfsMountReadRttDataPoint adds a data point to nfs.mount.read_rtt metric.
func (mb *MetricsBuilder) RecordNfsMountReadRttDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricNfsMountReadRtt.recordDataPoint(mb.startTime, ts, val)
}

// RecordNfsMountRPCBacklogDataPoint adds a data point to nfs.mount.rpc_backlog metric.
func (mb *MetricsBuilder) RecordNfsMountRPCBacklogDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricNfsMountRPCBacklog.recordDataPoint(mb.startTime, ts, val)
}

// RecordNfsMountWriteExeDataPoint adds a data point to nfs.mount.write_exe metric.
func (mb *MetricsBuilder) RecordNfsMountWriteExeDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricNfsMountWriteExe.recordDataPoint(mb.startTime, ts, val)
}

// RecordNfsMountWriteRttDataPoint adds a data point to nfs.mount.write_rtt metric.
func (mb *MetricsBuilder) RecordNfsMountWriteRttDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricNfsMountWriteRtt.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// Instance (NFS Proxy instance)
	Instance string
	// Path (NFS mount's path)
	Path string
	// Server (NFS mount's server)
	Server string
}{
	"instance",
	"path",
	"server",
}

// A is an alias for Attributes.
var A = Attributes
